<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>캐릭터 상세 정보</title>
    <link rel="stylesheet" href="css/detail.css" />
  </head>
  <body>
    <div id="character-profile"></div>
    <div id="detail-result">
      <p>상세 정보를 불러오는 중입니다...</p>
    </div>
    <div
      id="item-tooltip"
      class="item-tooltip"
      style="visibility: hidden"
    ></div>

    <script>
      let characterItemData = null;

      // ✨ [핵심 수정] window.onload 로직을 명확하게 수정
      window.onload = async function () {
        const urlParams = new URLSearchParams(window.location.search);
        const characterName = urlParams.get("characterName");

        // '비서'에게 정보 요청
        const response = await fetch(
          `/api/get-character-info?characterName=${encodeURIComponent(
            characterName
          )}`
        );
        if (!response.ok) {
          document.getElementById(
            "detail-result"
          ).innerHTML = `<p style="color: red;">'${characterName}' 님의 정보를 불러오는 데 실패했습니다.</p>`;
          return;
        }

        const info = await response.json();
        if (info.error) {
          document.getElementById(
            "detail-result"
          ).innerHTML = `<p style="color: red;">${info.error}</p>`;
          return;
        }

        const { basicData, statData, itemData } = info;

        if (!basicData) {
          document.getElementById(
            "detail-result"
          ).innerHTML = `<p style="color: red;">캐릭터 기본 정보를 불러오지 못했습니다.</p>`;
          return;
        }

        document.title = `${basicData.character_name} - 상세 정보`;

        // 툴팁이 사용할 전체 아이템 목록을 전역 변수에 저장
        characterItemData = itemData;

        // 화면에 프로필과 아이템 목록을 그리는 함수 호출
        displayCharacterProfile(basicData, statData);
        displayCharacterDetails(itemData); // ✨ 이제 itemData는 모든 아이템이 담긴 객체입니다.
      };

      function displayCharacterProfile(basicData, statData) {
        const profileDiv = document.getElementById("character-profile");
        const combatPowerStat = statData?.final_stat?.find(
          (stat) => stat.stat_name === "전투력"
        );
        const combatPower = combatPowerStat
          ? parseInt(combatPowerStat.stat_value).toLocaleString()
          : "정보 없음";

        let profileHtml = `
            <a href="index.html" class="home-button">🏠 홈으로</a>
            <div class="profile-image-container">
                <img src="${basicData.character_image}" alt="${basicData.character_name} 이미지" class="profile-image">
            </div>
            <div class="profile-info">
                <p class="profile-name">${basicData.character_name}</p>
                <p class="profile-level">Lv.${basicData.character_level} | ${basicData.character_class}</p>
                <p class="profile-power">전투력: ${combatPower}</p>
            </div>
            `;
        profileDiv.innerHTML = profileHtml;
      }

      function displayCharacterDetails(itemData) {
        const resultDiv = document.getElementById("detail-result");
        let itemHtml =
          '<h2>장착 장비 (모든 프리셋)</h2><div class="item-grid">';

        // ✨ itemData와 그 안의 item_equipment가 유효한지 다시 한번 확인
        if (
          itemData &&
          itemData.item_equipment &&
          itemData.item_equipment.length > 0
        ) {
          itemData.item_equipment.forEach((item) => {
            itemHtml += `
                <div class="item-box" data-item-name="${item.item_name}">
                    <img src="${item.item_icon}" alt="${item.item_name}">
                    <p>${item.item_name}</p>
                </div>
                `;
          });
        } else {
          itemHtml += "<p>장착한 장비 정보를 불러오지 못했습니다.</p>";
        }
        itemHtml += "</div>";
        resultDiv.innerHTML = itemHtml;

        attachItemHoverListeners();
      }

      function attachItemHoverListeners() {
        document.querySelectorAll(".item-box").forEach((box) => {
          box.addEventListener("mouseenter", handleMouseEnter);
          box.addEventListener("mouseleave", handleMouseLeave);
        });
      }

      // handleMouseEnter, handleMouseLeave 함수는 이전과 동일하게 유지
      // ... (이하 생략)
    </script>
  </body>
</html>
